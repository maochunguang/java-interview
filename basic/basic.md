# java基础的一些基本概念
## 1、java变量修饰符，
 修饰符  |  类内部 |  同个包（package） |  子类 |  其他范围
------------- | ------------- | -------------| -------------| -------------
public | Y |  Y |  Y |  Y
protected  |  Y |  Y |  Y |  N
无修饰符  |  Y |  Y |  N or Y(同一个包） |  N
private  |  Y |  N |  N |  N

## 2、java的基本类型有哪些？多少位？
boolean(1),byte(8),char(16),short(16),
int(32),float(32),double(64),long(64)

## 3、继承
* 定义：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。

* 说明：继承所描述的是“is-a”的关系，如果有两个对象A和B，若可以描述为“A是B”，则可以表示A继承B，其中B是被继承者称之为父类或者超类，A是继承者称之为子类或者派生类。实际上继承者是被继承者的特殊化，它除了拥有被继承者的特性外，还拥有自己独有得特性

## 继承的特征
1. 子类拥有父类非private的属性和方法。
2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
3. 子类可以用自己的方式实现父类的方法

## 4、封装
* 定义：隐藏对象的属性和实现细节，仅对外公开接口,控制在程序中属性的读和修改的访问级别。
* 封装的目的：增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，一特定的访问权限来使用类的成员。
* 封装的基本要求是:把所有的属性私有化，对每个属性提供getter和setter方法，如果有一个带参的构造函数的话，那一定要写一个不带参的构造函数。在开发的时候经常要对已经编写的类进行测试，所以在有的时候还有重写toString方法，但这不是必须的。

## 5、多态
多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。

## 6、overwrite overload区别
### override（重写，覆盖）
1. ​​方法名、参数、返回值相同
2. ​子类方法不能缩小父类方法的访问权限
3. 子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)
4. 存在于父类和子类之间
5. ​方法被定义为final不能被重写

### overload（重载，过载）

1. ​​参数类型、个数、顺序至少有一个不相同。
2. ​不能重载只有返回值不同的方法名。
3. 存在于父类和子类、同类中。

方法的重写(Overriding)和重载(Overloading)是Java多态性的不同表现。
重写(Overriding)是父类与子类之间多态性的一种表现，而重载(Overloading)是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被"屏蔽"了.

## 7、string,stringBuffer,stringBuild的区别
* String： 不可变字符串
* StringBuffer：可变字符串，线程安全，效率低
* StringBuild：可变字符串，线程不安全，效率高

## 8、==和equals的区别
* ==是比较两个对象引用地址是否一样，或者基本类型的值是否相等。
* equals在比较两个对象的时候，要根据对象实现的equals方法

## 9、&和&&的区别
### 运算执行：
* 对于：&   -- >  不管怎样，都会执行"&"符号左右两边的程序
* 对于：&& -- >  只有当符号"&&"左边程序为真(true)后，才会执行符号"&&"右边的程序。
### 运算规则：
* 对于：&  -- >  只要左右两边有一个为false，则为false；只有全部都为true的时候，结果为true
* 对于：&& -- > 只要符号左边为false，则结果为false；当左边为true，同时右边也为true，则结果为true

## 10、i++和++i的区别
首先int i=1,a=0;
* i++ 先运算在赋值,例如 a=i++,先运算a=i,后运算i=i+1,所以结果是a==1
* ++i 先赋值在运算,例如 a=++i,先运算i=i+1,后运算a=i,所以结果是a==2

## 11、hashcode和equals方法
* 只要重写 equals，就必须重写 hashCode。
* 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须重写这两个方法。
* 如果自定义对象做为 Map 的键，那么必须重写 hashCode 和 equals。

## 12、hashcode和equals方法的重写原则
* 原则 1 ： 如果 x.equals(y) 返回 “true”，那么 x 和 y 的 hashCode() 必须相等 ；
* 原则 2 ： 如果 x.equals(y) 返回 “false”，那么 x 和 y 的 hashCode() 有可能相等，也有可能不等 ；
* 原则 3 ： 如果 x 和 y 的 hashCode() 不相等，那么 x.equals(y) 一定返回 “false” ；
* 原则 4 ： 一般来讲，equals 这个方法是给用户调用的，而 hashcode 方法一般用户不会去调用 ；
* 原则 5 ： 当一个对象类型作为集合对象的元素时，那么这个对象应该拥有自己的equals()和hashCode()设计，而且要遵守前面所说的几个原则。

## 13、值传递和对象传递
* 对于基本类型，是值传递，
* 对于引用类型，是引用传递。

## 14、所有类的父类是哪个？有哪些方法？
java中所有类的父类是object，有以下方法：
* protected Object clone() 创建并返回此对象的一个副本。
* boolean equals(Object obj) 指示某个其他对象是否与此对象“相等”。
* int hashCode() 返回该对象的哈希码值。
* String toString() 返回该对象的字符串表示。
* protected void finalize() 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。
* Class<? extendsObject> getClass() 返回一个对象的运行时类。
* void notify() 唤醒在此对象监视器上等待的单个线程。
* void notifyAll() 唤醒在此对象监视器上等待的所有线程。
* void wait() 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。
* void wait(long timeout) 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。
* void wait(long timeout, int nanos) 导致当前的线程等待，直到其他线程调用此对象的 notify()
