# java基础的一些基本概念
## 1、java变量修饰符，
 修饰符  |  类内部 |  同个包（package） |  子类 |  其他范围
------------- | ------------- | -------------| -------------| -------------
public | Y |  Y |  Y |  Y
protected  |  Y |  Y |  Y |  N
无修饰符  |  Y |  Y |  N or Y(同一个包） |  N
private  |  Y |  N |  N |  N

## 2、java的基本类型有哪些？多少位？
boolean(1),byte(8),char(16),short(16),
int(32),float(32),double(64),long(64)

## 3、继承
* 定义：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。

* 说明：继承所描述的是“is-a”的关系，如果有两个对象A和B，若可以描述为“A是B”，则可以表示A继承B，其中B是被继承者称之为父类或者超类，A是继承者称之为子类或者派生类。实际上继承者是被继承者的特殊化，它除了拥有被继承者的特性外，还拥有自己独有得特性

## 继承的特征
1. 子类拥有父类非private的属性和方法。
2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
3. 子类可以用自己的方式实现父类的方法

## 4、封装
* 定义：隐藏对象的属性和实现细节，仅对外公开接口,控制在程序中属性的读和修改的访问级别。
* 封装的目的：增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，一特定的访问权限来使用类的成员。
* 封装的基本要求是:把所有的属性私有化，对每个属性提供getter和setter方法，如果有一个带参的构造函数的话，那一定要写一个不带参的构造函数。在开发的时候经常要对已经编写的类进行测试，所以在有的时候还有重写toString方法，但这不是必须的。

## 5、多态
多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。

## 6、overwrite overload区别
### override（重写，覆盖）
1. ​​方法名、参数、返回值相同
2. ​子类方法不能缩小父类方法的访问权限
3. 子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)
4. 存在于父类和子类之间
5. ​方法被定义为final不能被重写

### overload（重载，过载）

1. ​​参数类型、个数、顺序至少有一个不相同。
2. ​不能重载只有返回值不同的方法名。
3. 存在于父类和子类、同类中。

方法的重写(Overriding)和重载(Overloading)是Java多态性的不同表现。
重写(Overriding)是父类与子类之间多态性的一种表现，而重载(Overloading)是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被"屏蔽"了.

## 7、string,stringBuffer,stringBuild的区别
* String： 不可变字符串
* StringBuffer：可变字符串，线程安全，效率低
* StringBuild：可变字符串，线程不安全，效率高

## 8、==和equals的区别
* ==是比较两个对象引用地址是否一样，或者基本类型的值是否相等。
* equals在比较两个对象的时候，要根据对象实现的equals方法

## 9、&和&&的区别
### 运算执行：
* 对于：&   -- >  不管怎样，都会执行"&"符号左右两边的程序
* 对于：&& -- >  只有当符号"&&"左边程序为真(true)后，才会执行符号"&&"右边的程序。
### 运算规则：
* 对于：&  -- >  只要左右两边有一个为false，则为false；只有全部都为true的时候，结果为true
* 对于：&& -- > 只要符号左边为false，则结果为false；当左边为true，同时右边也为true，则结果为true

## 10、i++和++i的区别
首先int i=1,a=0;
* i++ 先运算在赋值,例如 a=i++,先运算a=i,后运算i=i+1,所以结果是a==1
* ++i 先赋值在运算,例如 a=++i,先运算i=i+1,后运算a=i,所以结果是a==2

## 11、hashcode和equals方法
* 只要重写 equals，就必须重写 hashCode。
* 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须重写这两个方法。
* 如果自定义对象做为 Map 的键，那么必须重写 hashCode 和 equals。

## 12、hashcode和equals方法的重写原则
* 原则 1 ： 如果 x.equals(y) 返回 “true”，那么 x 和 y 的 hashCode() 必须相等 ；
* 原则 2 ： 如果 x.equals(y) 返回 “false”，那么 x 和 y 的 hashCode() 有可能相等，也有可能不等 ；
* 原则 3 ： 如果 x 和 y 的 hashCode() 不相等，那么 x.equals(y) 一定返回 “false” ；
* 原则 4 ： 一般来讲，equals 这个方法是给用户调用的，而 hashcode 方法一般用户不会去调用 ；
* 原则 5 ： 当一个对象类型作为集合对象的元素时，那么这个对象应该拥有自己的equals()和hashCode()设计，而且要遵守前面所说的几个原则。

## 13、值传递和对象传递
* 对于基本类型，是值传递，
* 对于引用类型，是引用传递。

## 14、所有类的父类是哪个？有哪些方法？
java中所有类的父类是object，有11个方法：
* protected Object clone() 创建并返回此对象的一个副本。
* boolean equals(Object obj) 指示某个其他对象是否与此对象“相等”。
* int hashCode() 返回该对象的哈希码值。
* String toString() 返回该对象的字符串表示。
* protected void finalize() 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。
* Class<? extendsObject> getClass() 返回一个对象的运行时类。
* void notify() 唤醒在此对象监视器上等待的单个线程。
* void notifyAll() 唤醒在此对象监视器上等待的所有线程。
* void wait() 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。
* void wait(long timeout) 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。
* void wait(long timeout, int nanos) 导致当前的线程等待，直到其他线程调用此对象的 notify()

## 15、final，static，this，super关键字总结
### final关键字
final关键字主要用在三个地方：变量、方法、类。

对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。

当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。

使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。

### static关键字
1. 修饰成员变量和成员方法: 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：类名.静态变量名 类名.静态方法名()
2. 静态代码块: 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，静态代码块只执行一次.
3. 静态内部类（static修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。
4. 静态导包(用来导入类中的静态资源，1.5之后的新特性): 格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。

### this关键字
this关键字用于引用类的当前实例。 例如：
```java
class Manager {
    Employees[] employees;

    void manageEmployees() {
        int totalEmp = this.employees.length;
        System.out.println("Total employees: " + totalEmp);
        this.report();
    }

    void report() { }
}

```
在上面的示例中，this关键字用于两个地方：
* this.employees.length：访问类Manager的当前实例的变量。
* this.report（）：调用类Manager的当前实例的方法。
此关键字是可选的，这意味着如果上面的示例在不使用此关键字的情况下表现相同。 但是，使用此关键字可能会使代码更易读或易懂。

### super关键字
super关键字用于从子类访问父类的变量和方法。 例如：
```java
public class Super {
    protected int number;

    protected showNumber() {
        System.out.println("number = " + number);
    }
}

public class Sub extends Super {
    void bar() {
        super.number = 10;
        super.showNumber();
    }
}

```
在上面的例子中，Sub 类访问父类成员变量 number 并调用其其父类 Super 的 showNumber（） 方法。
**使用 this 和 super 要注意的问题：**
* 在构造器中使用 super（） 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。
* this、super不能用在static方法中。